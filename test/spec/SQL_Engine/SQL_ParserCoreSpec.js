// Generated by CoffeeScript 1.9.1
(function() {
  define(function(require) {
    var Patterns;
    Patterns = require('SQL_Engine/SQL_ParserCore');
    return describe('ParserCore', function() {
      var hello;
      hello = Patterns.txt('hello');
      it('should be difined', function() {
        return expect(Patterns).toBeDefined();
      });
      describe('txt', function() {
        it('should be a function', function() {
          return expect(Patterns.txt).toEqual(jasmine.any(Function));
        });
        it('should read predefined text', function() {
          return expect(hello.exec('hello', 0)).toEqual({
            res: 'hello',
            end: 5
          });
        });
        it('should return undefined when text does not match', function() {
          return expect(hello.exec('gghgjk', 0)).toBeUndefined();
        });
        return it('should read from the specified position', function() {
          expect(hello.exec('gghhello', 3)).toEqual;
          return {
            res: 'hello',
            end: 8
          };
        });
      });
      describe('rgx', function() {
        it('should be a function', function() {
          return expect(Patterns.rgx).toEqual(jasmine.any(Function));
        });
        it('should return undefined when rgx does not match', function() {
          return expect(Patterns.rgx(/\d+/).exec("hello world", 0)).toBeUndefined();
        });
        return it('should read from the specified position', (function(_this) {
          return function() {
            expect(Patterns.rgx(/hello/).exec('world hello', 6)).toEqual;
            return {
              res: 'hello',
              end: 11
            };
          };
        })(this));
      });
      describe('opt', function() {
        it('should be a function', function() {
          return expect(Patterns.opt).toEqual(jasmine.any(Function));
        });
        return it('should make pattern optional', function() {
          var optSelect, select;
          select = Patterns.txt('SELECT');
          optSelect = Patterns.opt(select);
          expect(optSelect.exec('SELECT * FROM')).toEqual;
          ({
            res: 'SELECT',
            end: 6
          });
          expect(optSelect.exec('SECT * FROM')).toEqual;
          return {
            res: void 0,
            end: 0
          };
        });
      });
      describe('exc', function() {
        var except, pattern;
        pattern = Patterns.rgx(/\d+/);
        except = Patterns.txt('23');
        it('should be a function', function() {
          return expect(Patterns.exc).toEqual(jasmine.any(Function));
        });
        it('should parse pattern and does not parse second', function() {
          return expect(Patterns.exc(pattern, except).exec('134', 0)).toEqual({
            res: '134',
            end: 3
          });
        });
        return it('should return undefined when second pattern parses', function() {
          return expect(Patterns.exc(pattern, except).exec('23', 0)).toBeUndefined();
        });
      });
      describe('any', function() {
        var firstPattern, secondPattern;
        firstPattern = Patterns.txt('INNER JOIN');
        secondPattern = Patterns.txt('LEFT JOIN');
        it('should be a function', function() {
          return expect(Patterns.any).toEqual(jasmine.any(Function));
        });
        it('should parse any pattern', function() {
          expect(Patterns.any(firstPattern, secondPattern).exec('INNER JOIN', 0)).toEqual({
            res: 'INNER JOIN',
            end: 10
          });
          return expect(Patterns.any(firstPattern, secondPattern).exec('LEFT JOIN', 0)).toEqual({
            res: 'LEFT JOIN',
            end: 9
          });
        });
        return it('should return undefined when any of patterns does not parses', function() {
          return expect(Patterns.any(firstPattern, secondPattern).exec('CROSS JOIN', 0)).toBeUndefined();
        });
      });
      describe('seq', function() {
        var firstPattern, secondPattern, thirdPattern;
        firstPattern = Patterns.txt('SELECT');
        secondPattern = Patterns.txt('*');
        thirdPattern = Patterns.txt('FROM');
        it('should be a function', function() {
          return expect(Patterns.seq).toEqual(jasmine.any(Function));
        });
        it('should parse queue of patterns', function() {
          return expect(Patterns.seq(firstPattern, secondPattern, thirdPattern).exec('SELECT*FROM', 0)).toEqual({
            res: ['SELECT', '*', 'FROM'],
            end: 11
          });
        });
        return it('should return undefined when any of patterns does not parses', function() {
          return expect(Patterns.seq(firstPattern, secondPattern, thirdPattern).exec('SELECT*FR', 0)).toBeUndefined();
        });
      });
      return describe('rep', function() {
        var firstPattern, secondPattern;
        firstPattern = Patterns.rgx(/\d+/);
        secondPattern = Patterns.txt(',');
        it('should be a function', function() {
          return expect(Patterns.rep).toEqual(jasmine.any(Function));
        });
        it('should parse first pattern excluding the result of the second', function() {
          return expect(Patterns.rep(firstPattern, secondPattern).exec('1,2,3', 0)).toEqual({
            res: ['1', '2', '3'],
            end: 5
          });
        });
        it('should return result of first pattern if second does not parses', function() {
          return expect(Patterns.rep(firstPattern, secondPattern).exec('1234', 0)).toEqual({
            res: ['1234'],
            end: 4
          });
        });
        return it('should return undefined when any of patterns does not parses', function() {
          expect(Patterns.rep(firstPattern, secondPattern).exec('s,s,s,s', 0)).toBeUndefined();
          return expect(Patterns.rep(firstPattern, secondPattern).exec('sss', 0)).toBeUndefined();
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=SQL_ParserCoreSpec.js.map
